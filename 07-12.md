# 07-12

---
#文件管理
###NSFileManager /  NSFilehandle  / plist文件 / NSData 的使用
---
##NSFileManager
####单例模式是一种常用的设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在，而且自行实例化并向整个系统提供这个实例。
####也就是说，对于一个单例类，不论实例化对象多少次，都只有一个对象实例，而且这个实例是全局的能被整个系统访问到,就像全局变量一样可以 被整个工程共享它的数据。
###功能——
    查看    创建    拷贝   移动   删除  等等
#####单例的体现
```
NSFileManager * fm = [NSFileManager defaultManager];
        NSFileManager * fm1 = [NSFileManager defaultManager];
        NSLog(@"%p  %p", fm, fm1);
        
        User *u1 = [User defaultUser];
        User *u2 = [User defaultUser];
        NSLog(@"%p %p", u1, u2);
```
####对于目录下的文件遍历有深遍历和浅遍历
#####浅遍历——contentsOfDirectoryAtPath: PATH error:&err
```
NSFileManager * fm = [NSFileManager defaultManager];
        NSError * err = nil;
//        遍历或是查看文件内容，注：不仅会得到文件夹名还会获取文件名，包含隐藏文件
//       [fm contentsOfDirectoryAtPath:文件夹的目录(如果是一个文件是没有意义的) error:&存放错误信息]
        NSMutableString * path = [PATH stringByAppendingString:@"sss"];
//        浅遍历
        NSArray * array = [fm contentsOfDirectoryAtPath: PATH error:&err];
        NSLog(@"%@", array);
```
#####深遍历——subpathsOfDirectoryAtPath:PATH error:&err
```
//        subpathsOfDirectoryAtPath 不仅会获取当前文件夹下的内容，还会下载子文件夹的内容。
//        深遍历
        NSArray * path2 = [fm subpathsOfDirectoryAtPath:PATH error:&err];
```
#####获取文件扩展名的两种方式
    1、if ([path hasPrefix:@".ppng"]) {
               NSLog(@"%@", path);
      }
    2、if([[path pathExtension] isEqualToString:@"png"]){
                NSLog(@"%@", path);
      }
####创建文件的方式
```
#import <Foundation/Foundation.h>
#define PATH @"/Users/zhangzengqiang/Desktop/张增强/Dir"
#define PATH2 @"/Users/zhangzengqiang/Desktop/张增强/Dir/OK"
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSFileManager * fm = [NSFileManager defaultManager];
        NSString * newPath1 = [PATH stringByAppendingPathComponent:@"ios3"];
        NSString * newPath2 = [PATH2 stringByAppendingPathComponent:@"ooook"];
        NSError * err = nil;
//        学一下创建
        BOOL create =  [fm createDirectoryAtPath:newPath1 withIntermediateDirectories:YES attributes:nil error:&err];
        BOOL create2 =  [fm createDirectoryAtPath:newPath2 withIntermediateDirectories:YES attributes:nil error:&err];
//        [fm createDirectoryAtPath:文件创建路径 withIntermediateDirectories:自动补全不存在的文件路径(中间路径)YES (不管目录是否存在都会创建成功)/ NO时会报错attributes:文件的属性 error:错误信息];
        if(create == true){
            NSLog(@"创建成功");
        }else{
            NSLog(@"创建失败 %@", err);
        }
        
        NSString * file1 = [PATH stringByAppendingPathComponent:@"12.txt"];
//        创建文件，PATH 是路径 ，comtents是文件内容。attributes 是属性
        BOOL fileCreate =  [fm createFileAtPath:file1 contents:nil attributes:nil];
        if (fileCreate == true) {
            NSLog(@"file successful");
        }else {
            NSLog(@"file failed.....");
        }
        
//        获取文件属性
        /**
         *
        NSDictionary * attr = [fm attributesOfItemAtPath:PATH error:nil];
        NSLog(@"%@", attr);
        NSDictionary * dic = [fm attributesOfFileSystemForPath:PATH error:nil];
        NSLog(@"%@", dic);
         */
        
    }
    return 0;
}
```
####文件的移动、删除、复制
####删除——
    [fm removeItemAtPath:PATH2 error:nil]
####移动
    [fm moveItemAtPath:movePath1 toPath:movePath2 error:&err]
####复制
    [fm copyItemAtPath:str1Path toPath:str2Path error:&err]
#####全部代码
```
#import <Foundation/Foundation.h>
#define PATH @"/Users/zhangzengqiang/Desktop/张增强/Dir/ios1"
#define PATH2 @"/Users/zhangzengqiang/Desktop/张增强/Dir/ios2"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSFileManager * fm = [NSFileManager defaultManager];
//        删除
//          删除路径中最后的元素，这样删除不会存放到废纸篓中
        BOOL remove = [fm removeItemAtPath:PATH2 error:nil];
        if (remove == true) {
            NSLog(@"remove successful...");
        }else{
            NSLog(@"remove failed...");
        }
//        拷贝
//        总结copy
//          1、PATH 指定的文件(目录)应该是存在，而 PATH2 指定的文件(目录)是不存在的。
//          2、如果PATH2 的文件(目录)已经存在，那么创建copy失败。
//          3、PATH2 的文件(目录)不一定有扩展名。
//        注：PATH 最后是文件夹目录就copy一个文件夹目录，如果是一个文件就是copy一个文件。
        NSError * err = nil;
        /**
         *
        NSString * str1Path = @"/Users/zhangzengqiang/Desktop/张增强/Dir/sss";
        NSString * str2Path = @"/Users/zhangzengqiang/Desktop/张增强/Dir/ios1/t";
        BOOL copyItem = [fm copyItemAtPath:str1Path toPath:str2Path error:&err];
        if (copyItem == true) {
            NSLog(@"copy successful...");
        }else{
            NSLog(@"copy failed.... %@", err);
        }
         */
        
//        移动，剪切
//        move 总结
//          注意事项，和copy类似
//              1、移动的目标目录一定要是不存在的目录
//              2、可以移动文件，目标文件也是不存在的，写上新写的文件名(即自动重名了)
//        移动可否完成文件夹的重命名?可以，在目标目录后面写上新的文件夹名字
        NSString * movePath1 = @"/Users/zhangzengqiang/Desktop/张增强/Dir/sss/2.png";
        NSString * movePath2 = @"/Users/zhangzengqiang/Desktop/张增强/Dir/sss/ss.jpg";
        BOOL moveLJ = [fm moveItemAtPath:movePath1 toPath:movePath2 error:&err];
        if (moveLJ == true) {
            NSLog(@"move successful....");
        }else {
            NSLog(@"move failed ..... %@", err);
        }
        
    }
    return 0;
}
```
---
##NSData的基本使用
####data类型转换为string
     NSData * data = [@"xiaoming wanghong" dataUsingEncoding:NSUTF8StringEncoding];
####string转换为data
    NSString * str = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
####注意事项——
    1、追加内容，不要交替出现，会发现意想不到的问题
    2、NSDate 存储的是二进制数据，网络传输，音视频、文件。NSMutableData
#####具体代码实现——
```
#import <Foundation/Foundation.h>
#define PATH @"/Users/zhangzengqiang/Desktop/张增强/Dir/ios3/ss.txt"
int main(int argc, const char * argv[]) {
    @autoreleasepool {
//        NSDate 存储的是二进制数据，网络传输，音视频、文件。NSMutableData
//        NSData * data = [NSData data];
        
//        把一个字符串转换成二进制数据。
        NSData * data = [@"xiaoming wanghong" dataUsingEncoding:NSUTF8StringEncoding];
        NSLog(@"%@", data);
//        把二进制数据转换成字符串
        NSString * str = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
        NSLog(@"%@", str);
        
//        contents 是存储的文件内容。
        NSFileManager * fm = [NSFileManager defaultManager];
        [fm createFileAtPath:PATH contents:data attributes:nil];
//        追加内容，不要交替出现，会发现意想不到的问题
        NSMutableData * mData = [NSMutableData data];
        [mData appendBytes:"xiaolizi" length:50];
        [mData appendBytes:"wangwu" length:22];
//        [mData appendData:data];
        NSLog(@"%@", [[NSString alloc] initWithData:mData encoding:NSUTF8StringEncoding]);
    }
    return 0;
}
```
---
##句柄NSFileHandle
####NSFileHandle 是对文件操作的类，文件句柄。可以对文件进行读和写
    fileHandleForReadingAtPath 创建的对象只能读，不能写。
    fileHandleForWritingAtPath 创建的对象只能写，不能读。
    fileHandleForUpdatingAtPath 创建的对象可读，可写
#####代码实现片段
```
//读取文件的方法
NSFileHandle * fh = [NSFileHandle fileHandleForReadingAtPath:PATH];
//        写入文件的方法
NSFileHandle * fh2 = [NSFileHandle fileHandleForWritingAtPath:PATH];
//        可读可写方法
NSFileHandle * fh3 = [NSFileHandle fileHandleForUpdatingAtPath:PATH];

NSData * data =  [fh readDataToEndOfFile];
NSString * string = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
NSLog(@"%@", string);
/**
*      fileHandleForReadingAtPath 创建的对象只能读，不能写。
*      fileHandleForWritingAtPath 创建的对象只能写，不能读。
*      fileHandleForUpdatingAtPath 创建的对象可读，可写
*/
[fh2 writeData:[@"DAMING ming " dataUsingEncoding:NSUTF8StringEncoding]];
NSLog(@"%@", fh);

[fh3 writeData:[@"LAJI ming " dataUsingEncoding:NSUTF8StringEncoding]];
NSLog(@"%@", fh3);
```

###句柄对于文件的读写控制，要是需要全部覆盖的话，需要
---
