# 07-06
---
#内存管理
##内存管理到底做了件什么事?
###出现问题的名称解释——
####*如果堆空间没有释放，称为【内存泄露】
####*使用已经释放的空间，称为【提前释放】
####*重复释放同一个空间，称为【重复释放】
##目前所存在的困境——
####(1) 当我们要释放一个堆，首先要确定使用这个堆的指针，都访问完毕。避免提前释放。
####(2)  释放指针指向的堆空间，首先要确定哪些指针指向同一个堆，这些指针，只能释放一个。避免重复释放。
####(3) 模块化操作，哪个模块负责释放，将成为巨大的难题。
####(4) 多线程操作，无法确定哪个线程最后使用完毕。 
---
#手动操作内存MRC
##1、在target中buildingsetting中搜索“gar”，改成“NO”。
##2、之后就能够运用retain、release等方法

###示例：
```
#import <Foundation/Foundation.h>
#import "Dog.h"
int main(int argc, const char * argv[]) {
    @autoreleasepool {
//        两种方式：MRC  ARC
//        创建一个dog对象,存放在堆中
        Dog * dog = [[Dog alloc] init];
//        创建时会使对象引用计数置为1
        
//        retain使使用对象的引用计数+1。
//        [dog retain];这样写是不正确，或者说是不合理的
        
        Dog * dog2 = [dog retain];
//        release使引用计数-1。在后面代码不再使用的时候要使用release，调用这个方法。
//        它是真正的释放内存吗？
        [dog2 release];
        NSLog(@"1===%lu", dog.retainCount);
//        dealloc才是真正的释放，但是我们不允许直接调用dealloc方法
//        [dog dealloc];
        
//        retainCount是对象的引用计数，本质上是个对象，有多个对象指向
        [dog release];//这里自动调用dealloc方法
//        理论上释放后应该是0，但实际上却是1。
//        引用计数只是作为对象是否被释放的参考，
//        下面这一句本来就不合理
        NSLog(@"2==== %lu", dog2.retainCount);
    }
    return 0;
}
```
---
#内存管理法则
    Δ1.凡是用alloc，retain，new(或使用new开头的方法)，copy(或使用copy开头的方法)，mutableCopy(或使用mutableCopy开头的方法)【创建】的对象，都必须使用release或autorelease方法【释放】
    Δ2.谁创建谁释放(哪个类创建，哪个类释放；谁写alloc，谁写release)。
##【注意事项】
####1.对象的成员变量在构造方法中创建，应在析构方法中释放。
####2.注意指针的转移 释放旧对象 保留新对象。
####3.从数据结构如数组中取出对象地址，如果需要长时间使用，应当retain。
```
#import <Foundation/Foundation.h>
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        /**
         *  1.凡是用alloc，retain，new(或使用new开头的方法)，copy(或使用copy开头的方法)，mutableCopy(或使用mutableCopy开头的方法)【创建】的 "对象"，都必须使用release或autorelease方法【释放】
         Δ2.谁创建谁释放(哪个类创建，哪个类释放；谁写alloc，谁写release)。
         
             此时严格遵循内存管理法则就好
         */
        NSString * str = @"xiaoming";
        NSString * str2 = [NSString new];
        NSString * str3 = [[NSString alloc] initWithString:str];
        NSString * str4 = [str3 retain];
        NSString * str5 = [NSString stringWithFormat:str];
//        以上对象那些需要release
        [str2 release];
        [str3 release];
        [str4 retain];
//        NSLog(@"%lu", str3.retainCount);
        
//        NSString * myStr = [[NSString alloc] initWithMyString];
//        [myStr release];
    }
    return 0;
}
```

---
#copy 和 mutableCopy 的使用
###容易出现的错误提示
    EXC_BAD_ACCESS 访问了不可访问的内存空间
    被系统回收的对象我们称之为僵尸对象
    如何可以检测。
    为了防止野指针操作,通常我们会把不在使用的指针变量赋值为nil
###示例——
```
#import <Foundation/Foundation.h>

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSMutableString * str = [[NSMutableString alloc] initWithString:@"i am good boy"];
        NSLog(@"111111========= %ld", str.retainCount);
        NSLog(@"%p", str);
        /**
         *  copy mutablecopy
         *  1、用copy 创建的对象是不可以改变的，(浅拷贝
         *  2、使用mutableCopy创建的对象是可以改变的。(深拷贝
         */
        NSMutableString * str2 = [str copy];
        NSLog(@"2222======= %ld", str2.retainCount);
        NSLog(@"%p", str2);
        NSMutableString * str3 = [str mutableCopy];
        NSLog(@"3333====== %ld", str3.retainCount);
        NSLog(@"%p", str3);
        [str release];
//        [str2 appendString:@" not true"];
        [str3 appendString:@" is true"];
        
        NSLog(@"str2: %@", str2);
        [str2 release];
        NSLog(@"str3: %@", str3);
        [str3 release];
        
        NSMutableString * string = [NSMutableString stringWithFormat:@"%@",@"i am"];
        NSLog(@"string --------- %ld", string.retainCount);
        NSString * string2 = [NSString stringWithFormat:@"%@", @"i am"];
        NSLog(@"string2 --------- %ld", string2.retainCount);
    }
    return 0;
}
```