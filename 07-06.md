# 07-06
---
#内存管理
##内存管理到底做了件什么事?
###出现问题的名称解释——
####*如果堆空间没有释放，称为【内存泄露】
####*使用已经释放的空间，称为【提前释放】
####*重复释放同一个空间，称为【重复释放】
##目前所存在的困境——
####(1) 当我们要释放一个堆，首先要确定使用这个堆的指针，都访问完毕。避免提前释放。
####(2)  释放指针指向的堆空间，首先要确定哪些指针指向同一个堆，这些指针，只能释放一个。避免重复释放。
####(3) 模块化操作，哪个模块负责释放，将成为巨大的难题。
####(4) 多线程操作，无法确定哪个线程最后使用完毕。 
---
#手动操作内存MRC
##1、在target中buildingsetting中搜索“gar”，改成“NO”。
##2、之后就能够运用retain、release等方法

###示例：
```
#import <Foundation/Foundation.h>
#import "Dog.h"
int main(int argc, const char * argv[]) {
    @autoreleasepool {
//        两种方式：MRC  ARC
//        创建一个dog对象,存放在堆中
        Dog * dog = [[Dog alloc] init];
//        创建时会使对象引用计数置为1
        
//        retain使使用对象的引用计数+1。
//        [dog retain];这样写是不正确，或者说是不合理的
        
        Dog * dog2 = [dog retain];
//        release使引用计数-1。在后面代码不再使用的时候要使用release，调用这个方法。
//        它是真正的释放内存吗？
        [dog2 release];
        NSLog(@"1===%lu", dog.retainCount);
//        dealloc才是真正的释放，但是我们不允许直接调用dealloc方法
//        [dog dealloc];
        
//        retainCount是对象的引用计数，本质上是个对象，有多个对象指向
        [dog release];//这里自动调用dealloc方法
//        理论上释放后应该是0，但实际上却是1。
//        引用计数只是作为对象是否被释放的参考，
//        下面这一句本来就不合理
        NSLog(@"2==== %lu", dog2.retainCount);
    }
    return 0;
}
```
---
#内存管理法则
    Δ1.凡是用alloc，retain，new(或使用new开头的方法)，copy(或使用copy开头的方法)，mutableCopy(或使用mutableCopy开头的方法)【创建】的对象，都必须使用release或autorelease方法【释放】
    Δ2.谁创建谁释放(哪个类创建，哪个类释放；谁写alloc，谁写release)。
##【注意事项】
####1.对象的成员变量在构造方法中创建，应在析构方法中释放。
####2.注意指针的转移 释放旧对象 保留新对象。
####3.从数据结构如数组中取出对象地址，如果需要长时间使用，应当retain。
```
#import <Foundation/Foundation.h>
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        /**
         *  1.凡是用alloc，retain，new(或使用new开头的方法)，copy(或使用copy开头的方法)，mutableCopy(或使用mutableCopy开头的方法)【创建】的 "对象"，都必须使用release或autorelease方法【释放】
         Δ2.谁创建谁释放(哪个类创建，哪个类释放；谁写alloc，谁写release)。
         
             此时严格遵循内存管理法则就好
         */
        NSString * str = @"xiaoming";
        NSString * str2 = [NSString new];
        NSString * str3 = [[NSString alloc] initWithString:str];
        NSString * str4 = [str3 retain];
        NSString * str5 = [NSString stringWithFormat:str];
//        以上对象那些需要release
        [str2 release];
        [str3 release];
        [str4 retain];
//        NSLog(@"%lu", str3.retainCount);
        
//        NSString * myStr = [[NSString alloc] initWithMyString];
//        [myStr release];
    }
    return 0;
}
```

